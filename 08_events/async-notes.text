the Task Queue (also called the Callback Queue or Macrotask Queue) is a key concept in how JavaScript handles asynchronous code.

Task Queue (Callback Queue) in JavaScript â€“ Notes
1. Purpose

Manages asynchronous callbacks in JavaScript.

Ensures non-blocking execution in a single-threaded environment.

2. How It Works

JS executes synchronous code in the Call Stack.

Async tasks (setTimeout, setInterval, I/O) are sent to Web APIs / Node APIs.

Once ready, their callbacks are pushed into the Task Queue.

The Event Loop checks:

If Call Stack is empty, it moves the first task from the queue to the stack.

Executes the callback.

Repeats continuously.

. Examples of Task Queue (Macrotasks)

setTimeout()

setInterval()

setImmediate() (Node.js)

I/O callbacks (Node.js)

UI events (click, input)

4. Microtask Queue vs Task Queue
Queue Type	Examples	Priority	Execution Timing
Microtask Queue	Promises, queueMicrotask(), MutationObserver	Higher	Runs immediately after current Call Stack finishes, before Task Queue
Task Queue (Macrotask Queue)	setTimeout, setInterval, I/O, UI events	Lower	Runs after microtasks and current stack finish
5. Example
console.log("Start");

setTimeout(() => console.log("Task Queue"), 0);

Promise.resolve().then(() => console.log("Microtask"));

console.log("End");


Execution Order:

Start â†’ End â†’ Microtask â†’ Task Queue

6. Key Points

JS is single-threaded, so the Call Stack can only run one thing at a time.

Task Queue ensures async tasks are executed later, without blocking.

Event Loop continuously moves tasks from queues â†’ Call Stack.

Microtasks always run before macrotasks.

       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚      Call Stack     â”‚
       â”‚ (Synchronous code) â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚     Web / Node APIs â”‚
       â”‚ (setTimeout, fetch, â”‚
       â”‚   I/O, DOM events) â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚     Task Queue       â”‚  â† Macrotasks
       â”‚ (setTimeout, setInt, â”‚
       â”‚ I/O callbacks, UI)  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Microtask Queue    â”‚  â† Higher priority
       â”‚ (Promises, Mutation â”‚
       â”‚ Observers, queueMicrotask) â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
              ðŸŒ€ Event Loop
       (moves tasks from queues â†’ Call Stack
        when stack is empty, microtasks first)


Execution Flow (Step-by-Step)

JS runs synchronous code â†’ Call Stack.

Async tasks go to Web/Node APIs â†’ when ready, callback goes to Task Queue.

If Promises or microtasks â†’ go to Microtask Queue.

Event Loop:

Checks if Call Stack is empty.

Runs all microtasks first.

Then runs first task from Task Queue.

Repeat continuously until program ends.


console.log("Start");

setTimeout(() => console.log("Task Queue"), 0);

Promise.resolve().then(() => console.log("Microtask"));

console.log("End");

Execution Order:

Start â†’ End â†’ Microtask â†’ Task Queue